
* 目录                                                    :TOC_4_gh:noexport:
- [[#安装][安装]]
  - [[#下载spacemacs][下载spacemacs]]
  - [[#我的配置][我的配置]]
  - [[#配置][配置]]
- [[#按键说明-keyboard][按键说明 keyboard]]
- [[#中文拼音输入法][中文拼音输入法]]
- [[#中文字体][中文字体]]
- [[#帮助文档][帮助文档]]
- [[#projectile][projectile]]
- [[#regexp-正则表达式][regexp 正则表达式]]
- [[#org][org]]
- [[#函数][函数]]
- [[#dired-mode][Dired Mode]]
- [[#性能][性能]]
  - [[#使用-profiler-start-和-profiler-report-来测试-emacs-性能][使用 profiler-start 和 profiler-report 来测试 Emacs 性能]]
  - [[#安装-rgripgrep-后在-project-内搜索文件时似乎要快很多][安装 rg[ripgrep] 后，在 project 内搜索文件时似乎要快很多]]
- [[#verilog-mode][verilog-mode]]
  - [[#配置-1][配置]]
  - [[#常用的一些功能][常用的一些功能]]
  - [[#verilog-auto][verilog-auto]]
  - [[#flycheck][flycheck]]
  - [[#imenu][imenu]]
  - [[#代码折叠][代码折叠]]
- [[#diff][diff]]
- [[#多位置编辑替换][多位置编辑替换]]

* 安装
** 下载spacemacs
   目前的配置基于[[https://github.com/syl20bnr/spacemacs][spacemacs]],
  #+begin_src sh
    git clone https://github.com/syl20bnr/spacemacs ~/.emacs.d
    cd ~/.emacs.d
    git checkout -b develop origin/develop; #默认的master分支更新较慢
  #+end_src

  码云家对它进行了镜像加速『鼓掌』, 上面的地址可能有点慢了，用下面的
  #+begin_src sh
    git clone https://gitee.com/mirrors/spacemacs ~/.emacs.d
    cd ~/.emacs.d
    git checkout -b develop origin/develop; #默认的master分支更新较慢
  #+end_src

  #+RESULTS:

** 我的配置
   由于众所周知的原因，国内访问github有时会 ...... 所以给个码云的地址
   #+begin_src sh
     git clone https://gitee.com/my2817/spacemacs-d ~/.spacemacs.d
   #+end_src
** 配置
   spacemacs本身依赖很多插件，安装这些插件时，还是因为众所周知的原因..... 不过已经有人做了比较好用的镜像，需要在 ~/.spacemacs.d/init.el中进行相应设置，找到如下代码，将local更新为emacs-china
   #+begin_src lisp
     (let ((melpa-source "local"))
       (cond
        ((string= melpa-source "emacs-china")
         (setq configuration-layer--elpa-archives
               '(("melpa-cn" . "http://elpa.emacs-china.org/melpa/")
                 ("org-cn"   . "http://elpa.emacs-china.org/org/")
                 ("gnu-cn"   . "http://elpa.emacs-china.org/gnu/"))))
        ((string= melpa-source "local")
         (setq configuration-layer-elpa-archives
               '(("melpa-cn-local" . "~/.emacs.d/.cache/elpa.emacs-china.org/melpa/")
                 ("org-cn-local"   . "~/.emacs.d/.cache/elpa.emacs-china.org/org/")
                 ("gnu-cn-local"   . "~/.emacs.d/.cache/elpa.emacs-china.org/gnu/")))
         )
        )
       )

   #+end_src
   如果使用local的话，需要事先将源下载到本地，如下
   #+begin_src sh
     rsync -avzp rsync:elpa.emacs-china.org/elpa/ ~/.emacs.d/.cache/elpa.emacs-china.org
   #+end_src

   如果是win平台，在文件 ~/.spacemacs.d/layers/my-config/config.el 中，找到如下代码，修改最后两个路径，为emacs提供linux工具集
   #+begin_src lisp
   (mapc #'wttr/prepend-to-exec-path
      (reverse
       '("D:/Perl/bin"
         "D:/EDA/graphviz-2.38/bin"
         "D:/cygwin64/bin"
         "D:/EDA/modeltech64_10.2c/win64"
         "d:/EDA/Git-2.6.0-32-bit/PortableGit/usr/bin"
         "C:/Program\ Files\ (x86)/Java/jre1.8.0_171/bin"
         "D:/EDA/Git-2.6.0-32-bit/PortableGit/bin"
         "D:/EDA/libxml2/iconv-1.9.2.win32/bin"
         "D:/EDA/libxml2/iconv-1.9.2.win32/lib"
         "D:/EDA/libxml2/libxml2-2.7.8.win32/bin"
         "D:/EDA/libxml2/libxml2-2.7.8.win32/lib"
         "D:/EDA/libxml2/zlib-1.2.5/bin"
         "D:/EDA/libxml2/zlib-1.2.5/lib"
         "C:/ProgramData/Oracle/Java/javapath"
         "e:/Git-2.6.0-32-bit/PortableGit/usr/bin"
         "e:/Git-2.6.0-32-bit/PortableGit/bin"
         )))
   #+end_src

* 按键说明 keyboard
  |----------------+----------------------------------------|
  | keys           | 说明                                   |
  |----------------+----------------------------------------|
  | ~c~            | 一般按键序列中的第一个c，代表  ctrl    |
  |----------------+----------------------------------------|
  | ~m~            | 一般按键序列中的第一个m，代表  alt     |
  |----------------+----------------------------------------|
  | ~c-K~          | ctrl和按键K同时按下                    |
  |----------------+----------------------------------------|
  | ~c-K J~        | 先同时按下ctrl和按键K，释放后再按键  J |
  |----------------+----------------------------------------|
  | ~m-x~          | 执行一个emacs内置命令                  |
  |----------------+----------------------------------------|
  | ~esc~ or ~c-[~ | 进入normal模式，同vim类似，            |
  |----------------+----------------------------------------|
  | ~i~, ~a~ , ~A~ | 进入插入模式                           |
  |----------------+----------------------------------------|

* 中文拼音输入法
  - 内置[[https://github.com/tumashu/pyim#orgb7116f0][pyim]]输入法,通过 ~C-\~ 在pyim和英文之间进行切换
  - 默认输入法被设置为五笔,[[./layers/my-config/packages.el::565][点我打开配置文件]],根据需要使用下面任意一行配置
   #+BEGIN_SRC lisp
      (setq pyim-default-scheme 'wubi)
      (setq pyim-default-scheme 'quanpin)
      (setq pyim-default-scheme 'xiaohe-shuangpin)
   #+END_SRC
  - 新的输入法rime,和 pyim 类似（但需要外部工具支持），可通过一下命令在两个输入法上切换
    #+begin_src elisp
      (setq default-input-method 'pyim)
      ;; or
      (setq default-input-method 'rime) ; default
    #+end_src
    将上面任意一行配置加入到 [[file:init.el][init.el 的函数 dotspacemacs/user-config]] 中修改启动后的默认配置

* 中文字体
  通过运行命令 cnfonts-edit-profile 配置好字体后，将标签栏“其它”下面的代码复制到  [[file:init.el][init.el 的函数 dotspacemacs/user-config]] 中

* 帮助文档
  + help 菜单下有详细说明，如果菜单被隐藏，使用 ctrl+鼠标右键呼出
  + 任何时候取消当前操作 ~c-g~ ，同 ~ESC~
  + 进入帮助系统: ~c-h~
  + 查看快捷键key绑定的功能： ~c-h k key~
  + 当前所有mode及按键绑定说明 ~c-h m~
  + 另spacemacs作为一套配置，其说明文档位置 "~/.emacs.d/doc/DOCUMENTATION.org"

* projectile
  + 指定一个 project：在 project 的根目录建立.projectile 文件（或者使用git init进行初始化），或者使用变量 projectile-project-root-files-系列变量
  + 忽略特定目录、文件：projectile-globally-ignore0*系列变量
  + 指定生成 TAGS 文件的命令：projectile-tags-command
    projectile+universal-ctags 设置要忽略生成 tag 的文件不在 project 根目录下时，ctags 的 --exclude=<path_pattern> 选项中，path_pattern 需要包含通配符“*”，更新 projectile 的一个 function
    #+begin_src emacs-lisp
      (defun projectile-tags-exclude-patterns ()
        "Return a string with exclude patterns for ctags."
        (mapconcat (lambda (pattern) (format "--exclude=\"*%s\""
                                             (directory-file-name pattern)))
                   (projectile-ignored-directories-rel) " "))
    #+end_src

  + 如果当前通过 .git 识别为 project，工作会自动调用 git 的 .gitignore 策略
  + 切换到project的目录，但不打开文件
#+BEGIN_SRC emacs-lisp
      (setq projectile-switch-project-action 'projectile-dired)
#+END_SRC

* regexp 正则表达式
  [[https://www.gnu.org/software/emacs/manual/html_node/emacs/Regexps.html#Regexps][regexp online doc]]

  语法见相关文档: 菜单 help-> search documentation ->，提示输入关键词，输入 "regexp"
凡事提示regexp的地方，均可使用regexp,

* org
  [[https://orgmode.org][Org-mode]]

  [[http://doc.norang.ca/org-mode.html][Orange Your Life In Plain Text!]]

 + 在任何 buffer 中使用插入 org 表格，使用 orgtbl-mode
 + org-babel，可以让许多不同语言的代码块一起工作
#+BEGIN_SRC lisp
(org-babel-do-load-languages
      'org-babel-load-languages
      '((emacs-lisp . t)
        (ruby . t)
        (ditaa . t)
        (python . t)
        (sh . t)
        (latex . t)
        (plantuml . t)
        (dot . t)
        (R . t)))
#+END_SRC

#+BEGIN_SRC verilog
  module test;
    input a;
    output b;

  endmodule
#+END_SRC

#+begin_src dot :file filename.jpg :cmdline -Kdot -Tjpg
digraph G {
  size="8,6"
  ratio=expand
  edge [dir=both]
  plcnet [shape=box, label="PLC Network"]
  subgraph cluster_wrapline {
    label="Wrapline Control System"
    color=purple
    subgraph {
    rank=same
    exec
    sharedmem [style=filled, fillcolor=lightgrey, shape=box]
    }
    edge[style=dotted, dir=none]
    exec -> opserver
    exec -> db
    plc -> exec
    edge [style=line, dir=both]
    exec -> sharedmem
    sharedmem -> db
    plc -> sharedmem
    sharedmem -> opserver
  }
  plcnet -> plc [constraint=false]
  millwide [shape=box, label="Millwide System"]
  db -> millwide

  subgraph cluster_opclients {
    color=blue
    label="Operator Clients"
    rankdir=LR
    labelloc=b
    node[label=client]
    opserver -> client1
    opserver -> client2
    opserver -> client3
  }
}
#+end_src

* 函数
 + flush-lines: 删除匹配的行，空行的正则表达式为"^\s-?+$" （即使有空白符，也算空行）
 + keep-lines: 如名字，功能与上一个命令相反
 + sort-lines: 对选中的行进行排序
 + 使用linux的 sort 命令进行复杂排序，比如第几个字段作为关键词进行排序
 + delete-duplicate-lines:先使用'sort-lines'对当前buffer进行排序，再使用本函数, 本函数一次只能从相邻的两行中删除一行，所以需要多次运行，或者使用以下awk命令（不需要事先排序）,该命令中的 $0 表示行内容完全重复时，进行删除操作，相应替换为$n，则表示当第n个字段相同时，进行删除操作。
 + ivy-push-view:将当前的窗口即对应的buffer信息保存起来，通过 ivy-switch-view可重新恢复该视图
 + my-highlight-symbol-in-frame: 通过多个 window 打开多个不同的文件），高亮显示光标下的 symbol （在所有的文件中）
#+BEGIN_SRC awk
  awk '{!a[$0]{print}}'
#+END_SRC

* Dired Mode
  - 复制文件名：比如想复制当前正在编辑的文件的文件名， ~spc f j~ ，移动光标到文件上， ~w~ ：复制文件名；或者 ~0 w~ :复制文件路径
  - 编辑文件名：在本模式下，默认的buffer是只读的， ~spc b w~ :buffer变为可写状态，根据需要个性文件名，再次 ~spc b w~ , 修改生效（修改时使用正则表达式进行复杂替换）

* 性能

** 使用 profiler-start 和 profiler-report 来测试 Emacs 性能
   别是你使用 starter-kit 的时候，比如使用 spacemacs，spacemacs 最大的问题可能就是性能了，通过 profiler-start 开启之后，做半个小时的工作，然后调用 profiler-report，看看哪些地方耗时比较多吧。
我把 pangu-spacing, org-bullets, js2-refactor 全部 exclude 了，现在打开 org 文件和 js 文件提升了不少效率。
另外之前我的配置编辑 js 文件性能极低，原因竟然是因为我以前不知道从哪里 copy 了一句配置：
#+BEGIN_SRC emacs-lisp
  ;; This line has very bad performance lose!!!!!!!!!!!!!!!!!!!
  (set-default 'imenu-auto-rescan t)
#+END_SRC

** 安装 rg[ripgrep] 后，在 project 内搜索文件时似乎要快很多
   https://github.com/BurntSushi/ripgrep/releases

* verilog-mode

  一般遇到的问题、需求，别人已经帮我们解决,见[[https://www.veripool.org/projects/verilog-mode/wiki/Faq][Faq]]
  在 verilog 模式下通过 ctrl + 鼠标右键呼出菜单，有3个 verilog 相关的菜单可关注一下

** 配置
   verilog相关插件有两个：
   + [[https:www.veripool.org][verilog-mode]] : 虽然emacs本身已经集成了，但不一定是最新版本（我一般是官网下载后，直接覆盖emac自带的，反正emacs都是自己安装）,另外意外的从官网发现了verilator,verilog-perl，似乎都比较好玩儿
   + [[file:layers/my-config/local/my-verilog/my-verilog.el][my-verilog.el]] : 这个文件的原始版本，是从网上抄过来的，现在似乎找不到出处，如果有人还记得，麻烦提醒一下，谢谢！

** 常用的一些功能
    + verilog-header: 原定义在verilog-mode.el中，我做了一定修改，放在my-verilog.el中，哪天跳槽了记得要改（前面已经说过了怎么查该函数对应的快捷键）
    + 代码补全：基于skeleton代码片断、框架补全,输入关键字，按照列表选择，可以不用方向键， ~c-j~ : down; ~c-k~ : up; ~c-l~ : 相当于回车
      本补全方式中，有时可能需要用户输入相应的信息，此时需要从minibuffer输入，此时不能使用关键字补全功能
      + [[file:img/company-module.png][company-keyword-module]]
      + [[file:img/module-expand.png][keyword-expand-module]]
    + yasnippet 代码片断补全,暂时没有加入到补全后端里，需要快捷键触发: ~M-m i s~ ,always as eg:
      + [[file:img/yasnippet-always.png][yasnippet-always]]
      + [[file:img/yasnippet-always-2.png][yasnippet-always2]] : 与skeleton不同，用户输入时不会使用minibuffer,同样可以使用关键字补全功能；使用tab跳转到下一个需要输入的位置
    + my-verilog-create-tb: 功能如名字所示,其会新建一个buffer，保存 ~c-x c-s~ ,  ~c-c c-a~  执行verilog-auto
    + verilog-auto时找不到instance? Faq中已经提示过了如何解决，或者参考 【 ~c-h f verilog-library-flags~ 】,麻烦的是每次遇到这问题都得在文件尾添加该语句 ..... 我的解决方案是利用[[https://www.gnu.org/software/emacs/manual/html_node/emacs/Directory-Variables.html#Directory-Variables][49.2.5 Per-Directory Local Variables]]，最后的解决方案就是执行命令 ~my-project-dir-local-init~ , 不过事先得先建一个project, 参考 projectile,另外，所有的RTL总得有个组织结构吧，比如：
      #+begin_example
      project-root
      +---digital
          +--rtl
             +--sub-module-a
             |  +--sub-module-a.v
             +--subm-module-b
                +--subm-module-b.v
      #+end_example
      ~my-project-dir-local-init~ 会在project的根目录下生成一个.dir-locals.el的文件，看见 "digital/rtl"了，意思是让只要是 protject-root/digtal/rtl 路径之下的所有 .v 均可被 verilog-auto 找到。
    + my-verilog-align-indent-inst-signal: 初始化代码如以下格式，其中 my-verilog-min-spc-for-align 用于控制端口和信号名之间最小的空格数量，默认值为1
      #+begin_src verilog
        module top(/*autoarg*/);

           sub1_x u_sub1     (/*autoinst*/);
           sub2_xxxxx u_sub2 (/*autoinst*/);
           sub3 #(/*autoinstparam*/)
           u_sub3(/*autoinst*/);

        endmodule // top


        module sub1_x(/*autoarg*/);
           input aa, bb, cc;
           output dd;
        endmodule // sub1

        module sub2_xxxxx(/*autoarg*/);
           input aa, bb, cc;
           output dd;
        endmodule // sub2

        module sub3 #(parameter
                      PAR_A = 10,
                      PAR_BB = 20,
                      PAR_ccc = 30
                      )
          (/*autoarg*/);
           input aaxx, bbxx, cc;
           output dd;
        endmodule // sub3

        // Local Variables:
        //  my-verilog-min-spc-for-align: 20
        // End:
      #+end_src
      默认会在"verilog-auto"后自动执行本命令（如果模块实例已经例化完成<--各端口信号独占一行，也可手动执行"my-verilog-align-indent-inst-signal"）。结果如下，所有实例的左括号对齐，所有端口信号对齐
      #+begin_src verilog
        module top(/*autoarg*/);

           sub1_x u_sub1     (/*autoinst*/
                              // Outputs
                              .dd                         (dd),
                              // Inputs
                              .aa                         (aa),
                              .bb                         (bb),
                              .cc                         (cc));
           sub2_xxxxx u_sub2 (/*autoinst*/
                              // Outputs
                              .dd                         (dd),
                              // Inputs
                              .aa                         (aa),
                              .bb                         (bb),
                              .cc                         (cc));
           sub3             #(/*autoinstparam*/
                              // Parameters
                              .PAR_A                      (PAR_A),
                              .PAR_BB                     (PAR_BB),
                              .PAR_ccc                    (PAR_ccc))
           u_sub3            (/*autoinst*/
                              // Outputs
                              .dd                         (dd),
                              // Inputs
                              .aaxx                       (aaxx),
                              .bbxx                       (bbxx),
                              .cc                         (cc));

        endmodule // top


        module sub1_x(/*autoarg*/
           // Outputs
           dd,
           // Inputs
           aa, bb, cc
           );
           input aa, bb, cc;
           output dd;
        endmodule // sub1

        module sub2_xxxxx(/*autoarg*/
           // Outputs
           dd,
           // Inputs
           aa, bb, cc
           );
           input aa, bb, cc;
           output dd;
        endmodule // sub2

        module sub3 #(parameter
                      PAR_A = 10,
                      PAR_BB = 20,
                      PAR_ccc = 30
                      )
          (/*autoarg*/
           // Outputs
           dd,
           // Inputs
           aaxx, bbxx, cc
           );
           input aaxx, bbxx, cc;
           output dd;
        endmodule // sub3

        // Local Variables:
        //  my-verilog-min-spc-for-align: 20
        // End:
      #+end_src
    + verilog-insert-indices：从“0”开始在当前列插入编号；如下代码，光标移动到第一行代码的“a”后面执行本命令，按提示输入编号的最大值
      #+begin_src  verilog
        a| = b                           a[  0] = b
        a = b                           a[  1] = b
        a = b                           a[  2] = b
        a = b                           a[  3] = b
        a = b   ==> insert-indices ==>  a[  4] = b
        a = b                           a[  5] = b
        a = b                           a[  6] = b
        a = b                           a[  7] = b
        a = b                           a[  8] = b
      #+end_src
    + verilog-generate-numbers：类似verilog-insert-indices
      #+begin_example
        buf buf|                             buf buf000
        buf buf                             buf buf001
        buf buf                             buf buf002
        buf buf                             buf buf003
        buf buf   ==> generate-numbers ==>  buf buf004
        buf buf                             buf buf005
        buf buf                             buf buf006
        buf buf                             buf buf007
        buf buf                             buf buf008"
      #+end_example

** verilog-auto

  当执行verilog-auto时，可能出现提示 "end xxxxx properties"信息，但verilog-auto并没有执行完成，使用emacs的batch mode解决
#+BEGIN_SRC sh
emacs --batch file.v -f verilog-batch-auto
#+END_SRC
  另，在我的配置中改写了verilog-mode中的一些函数，执行以上命令可能会出错，请使用以下命令：
#+BEGIN_SRC shell
emacs --batch file.v -l path/to/projectile.el -f verilog-batch-auto     #在spacemacs中, projectile.el位置 ~/.emacs.d/elpa路径下，请自查
#+END_SRC

** flycheck
   默认打开此功能，调用EDA工具对代码进行实时编译，简单低级错误可以立即提示，马上改掉 ~spc e v~ 大概得到如下信息，因为在我自己电脑上目前只安装了[[file:img/flycheck2.png][verilator]], 如果有多个EDA工具可用的话，可使用 ~spc e s~ 进行选择，需要定义其它工具的话自行搜索帮助文件，verilog-irun的定义在 "~/.spacemacs.d/layers/my-config/packages.el"
   #+begin_example
   Syntax checkers for buffer tb.sv in verilog-mode:

  verilog-irun (disabled)
    - may enable: Automatically disabled!
    - executable: Not found

  verilog-iverilog (disabled)
    - may enable: Automatically disabled!
    - executable: Not found

  verilog-leda (disabled)
    - may enable: Automatically disabled!
    - executable: Not found

  verilog-verilator
    - may enable: yes
    - executable: Found at /usr/local/bin/verilator_bin

   #+end_example

** imenu

   配置改写了verilog-mode默认产生imenu的方式，verilog代码可使用以下风格，将tag加入到imenu中实现快速跳转到该tag，

   #+BEGIN_SRC verilog
     module sub3 #(parameter
                   PAR_A = 10,
                   PAR_BBBBBB = 20,
                   PAR_ccc = 30
                   )
        (/*autoarg*/
         // Outputs
         dd,
         // Inputs
         aaxx, bbxx, cc
         );
        input aaxx, bbxx, cc;
        output dd;

        localparam // begin:localparam
          par_af = 10,
          par_ad = 20;

        always @ ( /*AUTOSENSE*/ ) begin
           if (xx) begin:reset
           end
           else begin: proce

           end

        end

        task func_a;

           begin

           end
        endtask // func_a

        function func_a;

           begin

           end
        endfunction // func_a

     endmodule // sub3
   #+END_SRC
   ~M-m s j~ 或者 ~SPC s j~ 提示如：
   [[file:./images/verilog-tag.png]]
** 代码折叠
   eamcs里代码太长的时候，可以使用下面的函数对begin-end代码进行折叠
   - hs-hide-block，折叠前，光标要在begin的下一行
   - hs-show-block, 展开光标所有行被折叠的代码

* diff
  参考 ediff-* 系列命令，很好用，该系列工具会出现至少包含一个名为 "*Ediff Control Pannel*" 的窗口，只有选中它时，才能使用其相关命令: ~?~ 查看帮助说明，再次 ~?~ 隐藏帮助说明, ~# #~:比较时忽略空白符，执行此操作后再进行一次 ~!~ , 就不会受空白符的影响了

  ediff-current-file: 对当前文件更改前后的内容进行比较

|------------------------------------------------+--------------------------------------------------------------------------------------------------------------------------|
| 比较项目                                       | 说明                                                                                                                     |
| ediff-regions-linewise, ediff-regions-         | 询问两个缓冲区的名字，然后比较相应的区域。不过你只能在每一个缓冲区中选定一个区域，而不能比较一个文件缓冲区的两个区域。   |
| ediff-buffers                                  | 询问两个缓冲区的名字，然后比较                                                                                           |
| ediff-files                                    | 询问两个文件的名字，加载之，然后比较                                                                                     |
| ediff-windows-linewise, ediff-windows-wordwise | 让你选两个窗口，然后比较窗口的内容。 -linewise- 函数比 -wordwise- 函数要快，                                             |
|                                                | 但另一方面， -wordwise- 工作方式更好，尤其是小区域作业时。 -linewise- 一行一行地比较， -wordwise- 一个单词一个单词地比较 |
|------------------------------------------------+--------------------------------------------------------------------------------------------------------------------------|

|----------------+-----------------------------------+----------------------------------------------------------------------|
| 快捷键         | 命令                              | 说明                                                                 |
|----------------+-----------------------------------+----------------------------------------------------------------------|
| q              | ediff-quit                        | 关闭 ediff control buffer， 并退出 ediff                             |
| Space 或 n     | ediff-next-difference             | 下一个差异处                                                         |
| Del 或 p       | ediff-previous-difference         | 上一个差异处                                                         |
| [n]j           | ediff-jump-to-difference          | 有数字前缀 [n] 修饰，第n个差异处,n可为负数                           |
| v 或 C-v       | ediff-scroll-vertically           | 所有缓冲区同步向下滚动                                               |
| V 或 M-v       | ediff-scroll-vertically           | 所有缓冲区同步向上滚动                                               |
| <              | ediff-scroll-horizontally         | 所有缓冲区同步向左滚动                                               |
| >              | ediff-scroll-horizontally         | 所有缓冲区同步向右滚动                                               |
| (vertical bar) | ediff-toggle-split                | 切换缓冲区布局方式, 水平和竖直                                       |
| m              | ediff-toggle-wide-display         | 在正常 frame 大小和最大化之间切换                                    |
| a              | ediff-copy-A-to-B                 | 把Buffer-A的内容复制到Buffer-B                                       |
| b              | ediff-copy-B-to-A                 | 把Buffer-B的内容复制到Buffer-A                                       |
| r a 或 r b     | ediff-restore-diff                | 恢复 Buffer-A 或 Buffer-B 差异区域中的被修改的内容                   |
| A 或 B         | ediff-toggle-read-only            | 切换 Buffer-A 或 Buffer-B 的只读状态                                 |
| g a 或 g b     | ediff-jump-to-difference-at-point | 根据光标在缓冲区中的位置，设置一个离它们最近的差异区域为当前活动区域 |
| C-l            | ediff-recenter                    | 恢复先前的所有缓冲区比较的高亮差异区。                               |
| ~!~            | ediff-update-diffs                | 重新比较并高亮差异区域                                               |
| w a 或 w b     | ediff-save-buffer                 | 保存 Buffer-A 或 Buffer-B 到磁盘                                     |
| E              | ediff-documentation               | 打开 Ediff 文档                                                      |
| z              | ediff-suspend                     | 关闭 ediff control buffer, 只是挂起，可在以后恢复 ediff 状态         |
|----------------+-----------------------------------+----------------------------------------------------------------------|

* 多位置编辑替换
  原理，对搜索列出的候选项进行编辑
  - ~spc s p~ 搜索当前基础上，或者 ~spc s d~搜索当前目录
  - 列出候选项后 ~C-c C-e~，会给出新的buffer，进入多处替换模式
  - 在该buffer中对候选项进行编辑
  - 编辑完成后，进入普通模式，按~,~ ，根据提示
    - wgrep-abort-changes:放弃修改
    - wgrep-finish-edit:完成修改
      - wgrep-save-all-buffers:将所有修改保存到文件
    - ~q~ 退出该模式
